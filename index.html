<!DOCTYPE html>
<html>
<head>
    <title>Adventures in New Arvandal</title>
    <link rel="stylesheet" href="webpage/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>


  <div class="container" style="padding-left:0;">
    <div class="row" style="align-items:start;">
      <div class="col-2 nav-wrapper" style="width:auto;min-width:100px;max-width:110px;flex-basis:20%;padding:0;">
        <div class="navigation" style="width:110px;min-width:90px;">
          <ul style="margin:0;padding:0;text-align:left;">
            <li><button class="btn" style="text-align:left;width:100%;" onclick="setContentPage('/vault/database/game_rules.md')">Rules</button></li>
            <li><button class="btn" style="text-align:left;width:100%;" onclick="setContentPage('/vault/database/spellbook.md')">Spellbook</button></li>
            <li><button class="btn" style="text-align:left;width:100%;" onclick="setContentPage('/vault/database/wildshapes.md')">Wildshapes</button></li>
            <li><button class="btn" style="text-align:left;width:100%;" onclick="setContentPage('/vault/database/alchemy.md')">Alchemy</button></li>
          </ul>
        </div>
      </div>
      <div class="col-2 dndcontent" style="width:auto;min-width:100px;flex-basis:60%;"></div>

      <div class="col-2 nav-wrapper" style="width:auto;min-width:100px;flex-basis:20%;padding:0;">
        <div class="navigation dndindex" style="width:auto;min-width:100px;flex-basis:20%;"></div>
      </div>
    </div>
  </div>
    
  <script>
    function setNavPosition()
    {
      const navigationDivs = document.querySelectorAll('.navigation'); 
      navigationDivs.forEach((navigation) => {
        const wrapperRect = navigation.parentElement.getBoundingClientRect();
        {
          let computedStyle = window.getComputedStyle(navigation);
          let minWidth = parseFloat(computedStyle.getPropertyValue('min-width')) + 0.1;
          let currentWidth = parseFloat(computedStyle.getPropertyValue('width'));
          var hasSpaceNextToContent = currentWidth > minWidth && parseFloat(window.innerWidth) > 600;
        }

        navigation.style.width = `${wrapperRect.width}px`;

        if (window.scrollY > 0 && hasSpaceNextToContent ) 
        {
          navigation.style.position = 'fixed';
          navigation.style.top = 0;
          navigation.style.left = `${wrapperRect.left}px`;
        } 
        else 
        {
          navigation.style.position = 'relative';
          navigation.style.top = '0px';
          navigation.style.left = '0px';
        }
      });
    }

    //
    //PARSER FROM HERE
    //
    //

    function reformatHeader(line)
    {
      let resultH = "";
      if (line.startsWith("# ")) {resultH = "h1"; line = line.substring(2);}
      else if (line.startsWith("## ")) {resultH = "h2"; line = line.substring(3);}
      else if (line.startsWith("### ")) {resultH = "h3"; line = line.substring(4);}
      else if (line.startsWith("#### ")) {resultH = "h4"; line = line.substring(5);}
      else if (line.startsWith("##### ")) {resultH = "h5"; line = line.substring(6);}
      else if (line.startsWith("##### ")) {resultH = "h6"; line = line.substring(7);}
      else
      {
        //it's a token, just leave it.
        return line;
      }

      return '<' + resultH + '>' + line + '</' + resultH + '>';
    }

    function parseMd(input)
    {
      const lines = input.split('\n');
    
      for (let i = 0; i < lines.length; ++i)
      {
        //Annoying things
        if(lines[i].trim() === "")
        {
          continue;
        }
        else if (lines[i].startsWith("#"))
        {
          lines[i] = reformatHeader(lines[i]);
          continue;
        }
        else if(lines[i].trimStart().startsWith(">[!INFO]"))
        {
          //TODO maybe get obsidian specifics into this
        }

        //images 
        lines[i] = lines[i].replace(/!\[([^\|]+)\|([^\]]+)\]\(([^)]+)\)/g, '<img src="$3" style="width:$2px;">');

        //bold
        lines[i] = lines[i].replace(/\*\*([^ ][^*]*[^ ])\*\*/g, "<b>$1</b>");
        
        //italic
        lines[i] = lines[i].replace(/\*([^ ][^*]*[^ ])\*/g, "<i>$1</i>");
  
        let indent = 0;
        let counter = 0;
        while(counter < lines[i].length && lines[i][counter++] === " ")
        {
          indent += 10;
        }

        //paragraph
        lines[i] = '<p style="margin-left:'+ indent.toString() + 'px;">' + lines[i] + '</p>';
      }

      //Tables
      for (let i = 0; i < lines.length; ++i)
      {
        let tableMatches = lines[i].match(/[ ]?(:?--:?)[ ]?\|?/g);
        
        if (i > 0 && tableMatches && tableMatches.length > 1)
        {          
          let columns = new Array(tableMatches.length);
          for (let j = 0; j < tableMatches.length; ++j)
          {
            const leftalign = '<td style="text-align:left;"><p>';
            const centeralign = '<td style="text-align:center;"><p>';
            const rightalign = '<td style="text-align:right;"><p>';
            
            if (tableMatches[j].trimStart().startsWith(":")) 
            {
              if (tableMatches[j].trimStart().startsWith(":--:"))
              {
                columns[j] = centeralign;
              }
              else
              {
                columns[j] = leftalign;
              }
            }
            else 
            {
              columns[j] = rightalign;
            }     
          }

          for (let j = i-1; j < lines.length; ++j)
          {
            if (j == i)
            {
              lines[j] = ''; 
            }
            else
            {
              if (lines[j].trim() === "")
              {
                lines[j] = '</table>';
                break;
              }
              let k = 1;
              let newLineContent = '<tr>' + columns[0] + lines[j].replace(/\|/g, () => ( '</p></td>' + columns[k++]) || "|") + '</td></tr>';
              lines[j] = newLineContent;
            }
          }
          lines[i-1] = '<table>' + lines[i-1];
        }
      }
      

      return lines.join('');
    }

    async function fetchMdAsHtml(relativeMdPath)
    {
      let mdUrl = "https://ninetalesgh.github.io/dndcampaign/" + relativeMdPath;
      try 
      {
        const response = await fetch(mdUrl);

        if (!response.ok)
        {
          throw new Error('network error');
        }

        const data = await response.text();
        return parseMd(data);
      }
      catch (error)
      {
        console.error('fetch error', error);
      }
    }

//////////////////////////////////////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////
/// INDEXING
//////////////////////////////////////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////

    class TreeNode {
      constructor(value){
        this.name = value ? value.innerText : "";
        this.element = value;
        this.parent = null;
        this.children = [];
      }
      addChild(childNode) {
        this.children.push(childNode);
        childNode.parent = this;
      }
    }
    var rootNode = new TreeNode(null);
  
    function addTreeNodeToList(treeNode, parentElement)
    {
      parentElement.innerHTML = treeNode.name; 
      if (treeNode.children.length > 0)
      {
        const unorderedList = document.createElement('ul'); 
        treeNode.children.forEach(childNode => {
          const listItem = document.createElement('li');          
          addTreeNodeToList(childNode, listItem);
          unorderedList.appendChild(listItem);
        });
        parentElement.appendChild(unorderedList);
      }
    }

    function generateIndexTree(rootTreeNode, content)
    {
      let element = content.firstChild;
      let previousDepth = '';
      let currentNode = rootTreeNode;
      while(element)
      {
        let currentDepth = '';
        if(element.localName === 'h1') { currentDepth = element.localName; }
        else if(element.localName === 'h2') { currentDepth = element.localName; }
        else if(element.localName === 'h3') { currentDepth = element.localName; }
        else if(element.localName === 'h4') { currentDepth = element.localName; }
        else if(element.localName === 'h5') { currentDepth = element.localName; }
        else if(element.localName === 'h6') { currentDepth = element.localName; }

        if (currentDepth !== '')
        {
          if (currentDepth <= previousDepth)
          {
            currentNode = currentNode.parent;
          }
          
          let childNode = new TreeNode(element);
          currentNode.addChild(childNode);
          currentNode = childNode;          
          previousDepth = currentDepth;
        }
        element = element.nextElementSibling;
      }
    }


    function getIndexedContentPage(name) { return rootNode.children.find(node => node.name === name); }

    function indexContent(name, content)
    {
      let test = getIndexedContentPage(name);

      if (!getIndexedContentPage(name))
      {
        let newNode = new TreeNode(null);
        newNode.parent = rootNode;
        newNode.name = name;
        rootNode.addChild(newNode);

        generateIndexTree(newNode, content);
      }
    }

    async function fetchMd(relativeMdUrl)
    {
      console.log('fetch & cache: ' + relativeMdUrl);

      let div = null;
      await fetchMdAsHtml(relativeMdUrl)
      .then(data => {
        div = document.createElement('div');
        div.innerHTML = data;
        indexContent(relativeMdUrl, div);
      });
      
      return div;
    }
    
    function applyNodeToView(node)
    {
      const contentHolder = document.querySelector('.dndcontent');
      contentHolder.innerHTML = node.element.outerHTML;
          
      let index = document.querySelector('.dndindex');
      index.innerHTML = '';
      addTreeNodeToList(node, index);
    }

    function setContentPage(relativeMdUrl)
    {
      let contentNode = getIndexedContentPage(relativeMdUrl);

      if (contentNode)
      {
        applyNodeToView(contentNode);
      }
      else
      {
        fetchMd(relativeMdUrl).then((div) => {
          let contentNode = getIndexedContentPage(relativeMdUrl);
          if (contentNode)
          {
            contentNode.element = div;
          }
          else
          {
            console.log("huh 1");
          }
        }).then(() => {
          let contentNode = getIndexedContentPage(relativeMdUrl);
          if (contentNode)
          {
            applyNodeToView(contentNode);
          }
          else
          {
            console.log("huh 2");
          }
        });
      }
    }

    setContentPage('/vault/database/game_rules.md');

    window.addEventListener('scroll', setNavPosition);
    window.addEventListener('resize', setNavPosition);
    window.addEventListener('load', () => 
    {
        const navigation = document.querySelector('.navigation');
        navigation.style.top = '0px';
    });

  </script>

</body>
</html>